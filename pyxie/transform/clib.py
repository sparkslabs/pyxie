#!/usr/bin/python

#
# Note: This file is autogenerated from clib, using clib/mk_py_clib.py and the C++ files.
# Make edits there not here - changes here will be overwritten!
#
files = {'iterators.cpp': '//\n// This file contains code generated by Pyxie - http://www.sparkslabs.com/pyxie\n//\n// This file contains parts of code derived from Pyxie itself. It may be used\n// under the following terms:\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the "Software"),\n// to deal in the Software without restriction, including without limitation\n// the rights to use, copy, modify, merge, publish, distribute, sublicense,\n// and/or sell copies of the Software, and to permit persons to whom the Software\n// is furnished to do so, subject to the following conditions:\n//\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n//\n// For more information see: http://www.sparkslabs.com/pyxie/COPYING.output.md\n//\n\n#include "iterators.hpp"\n\nstruct range : public Generator<int> {\n    int start;\n    int end;\n    int step;\n\n    int index;\n\n    range() :                                start(0),     end(0),   step(1), index(0)            {     };\n    range(int end) :                         start(0),     end(end), step(1), index(0)            {     };\n    range(int start, int end)     :          start(start), end(end), step(1), index(start)        {     };\n    range(int start, int end, int stepsize): start(start), end(end), step(stepsize), index(start) {     };\n    ~range() {     };\n\n    virtual int next() {\n        GENERATOR_START\n\n        while ( step>0  ? index < end : index > end) {\n            YIELD(index);\n            index = index + step;\n        }\n\n        GENERATOR_END\n    }\n};\n', 'iterators.hpp': '//\n// This file contains code generated by Pyxie - http://www.sparkslabs.com/pyxie\n//\n// This file contains parts of code derived from Pyxie itself. It may be used\n// under the following terms:\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the "Software"),\n// to deal in the Software without restriction, including without limitation\n// the rights to use, copy, modify, merge, publish, distribute, sublicense,\n// and/or sell copies of the Software, and to permit persons to whom the Software\n// is furnished to do so, subject to the following conditions:\n//\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n//\n// For more information see: http://www.sparkslabs.com/pyxie/COPYING.output.md\n//\n\n#ifndef PYXIE_ITERATORS_HPP\n#define PYXIE_ITERATORS_HPP\n\n/*\n * Python Style Iterators in C++, based in part on experiment work in Kamaelia\n * Redone to remove use of generators, so that this can be used on Arduino\n * \n */\n\n#define GENERATOR_START if (this->__generator_state == -1) { return __default_value; } switch(this->__generator_state) { default:\n#define YIELD(value)    this->__generator_state = __LINE__; return ((value) );   case __LINE__:\n#define GENERATOR_END    }; this->__generator_state = -1; return __default_value;\n\ntemplate<class T>\nstruct Iterator {\n    virtual T next()=0;\n    virtual bool completed()=0;\n};\n\ntemplate<class T>\nclass Generator : public Iterator<T> {\n  protected:\n    int __generator_state;\n  public:\n    T __default_value;\n    Generator() : __default_value(T()) {     };\n    ~Generator() {     };\n    virtual bool completed() { return __generator_state==-1; };\n};\n\n#endif\n', 'iterators_test.cpp': '/*\n * Test of a C++ version of Python style generators.\n * \n */\n\n#include <iostream>\n#include "iterators.cpp"\n/*\n\nWhile it may be a little unclear, this C++ program is equivalent\nto this python program:\n\nfor count in range(5):\n    print count,\n\nprint\n\nIt doesn\'t do this:\n\nfor(int count=0; count<5; count++) {\n    std::cout << count;\n}\nstd::cout << "." << std::endl;\n\nBecause doing it the way we do makes it avoid treating for/range as a\nspecial case, meaning we solve the harder problem first.  Optimisations\nspecific to certain code structures can come later.\n\n*/\n\n\nint main(int argc, char* argv[]) {\n    // Code to be replaced with a range() style iterator\n    int count;\n    range range_gen = range(5);\n\n    while (true) {\n        count = range_gen.next();\n        if (range_gen.completed())\n            break;\n        std::cout << count;\n    }\n    std::cout << "." << std::endl;\n\n    return 0;\n}\n'}

