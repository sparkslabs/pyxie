#!/usr/bin/python

#
# Note: This file is autogenerated from clib, using clib/mk_py_clib.py and the C++ files.
# Make edits there not here - changes here will be overwritten!
#
files = {'iterators.cpp': '#include "iterators.hpp"\n\nstruct range : public Generator<int> {\n    int start;\n    int end;\n    int step;\n\n    int index;\n\n    range() :                                start(0),     end(0),   step(1), index(0)            {     };\n    range(int end) :                         start(0),     end(end), step(1), index(0)            {     };\n    range(int start, int end)     :          start(start), end(end), step(1), index(start)        {     };\n    range(int start, int end, int stepsize): start(start), end(end), step(stepsize), index(start) {     };\n    ~range() {     };\n\n    virtual int next() {\n        GENERATOR_START\n\n        while ( step>0  ? index < end : index > end) {\n            YIELD(index);\n            index = index + step;\n        }\n\n        GENERATOR_END\n    }\n};\n', 'iterators.hpp': '#ifndef PYXIE_ITERATORS_HPP\n#define PYXIE_ITERATORS_HPP\n\n/*\n * Python Style Iterators in C++, based in part on experiment work in Kamaelia\n * Redone to remove use of generators, so that this can be used on Arduino\n * \n */\n\n#define GENERATOR_START if (this->__generator_state == -1) { return __default_value; } switch(this->__generator_state) { default:\n#define YIELD(value)    this->__generator_state = __LINE__; return ((value) );   case __LINE__:\n#define GENERATOR_END    }; this->__generator_state = -1; return __default_value;\n\ntemplate<class T>\nstruct Iterator {\n    virtual T next()=0;\n    virtual bool completed()=0;\n};\n\ntemplate<class T>\nclass Generator : public Iterator<T> {\n  protected:\n    int __generator_state;\n  public:\n    T __default_value;\n    Generator() : __default_value(T()) {     };\n    ~Generator() {     };\n    virtual bool completed() { return __generator_state==-1; };\n};\n\n#endif\n', 'iterators_test.cpp': '/*\n * Test of a C++ version of Python style generators.\n * \n */\n\n#include <iostream>\n#include "iterators.cpp"\n/*\n\nWhile it may be a little unclear, this C++ program is equivalent\nto this python program:\n\nfor count in range(5):\n    print count,\n\nprint\n\nIt doesn\'t do this:\n\nfor(int count=0; count<5; count++) {\n    std::cout << count;\n}\nstd::cout << "." << std::endl;\n\nBecause doing it the way we do makes it avoid treating for/range as a\nspecial case, meaning we solve the harder problem first.  Optimisations\nspecific to certain code structures can come later.\n\n*/\n\n\nint main(int argc, char* argv[]) {\n    // Code to be replaced with a range() style iterator\n    int count;\n    range range_gen = range(5);\n\n    while (true) {\n        count = range_gen.next();\n        if (range_gen.completed())\n            break;\n        std::cout << count;\n    }\n    std::cout << "." << std::endl;\n\n    return 0;\n}\n'}

